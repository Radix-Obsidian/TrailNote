/**
 * TrailNote Intelligence Hub
 * 
 * Central initialization and wiring module.
 * This is the single entry point that initializes all pedagogical intelligence
 * engines and connects them to the existing TrailNote modules.
 * 
 * Architecture:
 *   tutor.js ──────────────────▶ hub.beforeHint() ──▶ Orchestration Graph
 *                                                     └▶ Pedagogical Engine
 *                                                     └▶ Learning Memories
 *   outcome-tracker.js ────────▶ hub.onOutcome() ───▶ Feedback Loop
 *                                                     └▶ BKT Engine
 *                                                     └▶ Learning Velocity
 *   struggle-detector.js ──────▶ hub.onStruggle() ──▶ Pedagogical Engine
 *   concept-graph.js ──────────▶ hub.onConceptPass() ▶ BKT Engine
 *   panel-v2.js ───────────────▶ hub.init() ─────────▶ All Engines
 *                                hub.getStatus() ─────▶ UI Rendering
 */

// All engines are loaded lazily to avoid blocking startup
let _orchestrationGraph = null;
let _bktEngine = null;
let _pedagogicalEngine = null;
let _feedbackLoop = null;
let _learningMemories = null;
let _learningVelocity = null;
let _patternMiner = null;

/**
 * Intelligence Hub
 * Singleton that manages all pedagogical intelligence engines
 */
class IntelligenceHub {
  constructor() {
    this.initialized = false;
    this.initializing = false;
    this._initPromise = null;
    
    // Track current session state
    this.currentSession = {
      hintId: null,
      conceptId: null,
      misconceptionType: null,
      interventionStyle: null,
      startTime: null,
      struggleLevel: 'none',
      hintStartTime: null
    };
    
    // Event listeners for UI updates
    this._listeners = new Map();
  }

  /**
   * Initialize all engines
   * Safe to call multiple times - only initializes once
   */
  async init() {
    if (this.initialized) return;
    if (this._initPromise) return this._initPromise;
    
    this._initPromise = this._doInit();
    return this._initPromise;
  }

  async _doInit() {
    console.log('[IntelligenceHub] Initializing pedagogical intelligence engines...');
    this.initializing = true;
    
    try {
      // Initialize engines in dependency order
      const { bktEngine } = await import('./bkt-engine.js');
      await bktEngine.init();
      _bktEngine = bktEngine;
      console.log('[IntelligenceHub] ✓ BKT Engine ready');

      const { feedbackLoop } = await import('./feedback-loop.js');
      await feedbackLoop.init();
      _feedbackLoop = feedbackLoop;
      console.log('[IntelligenceHub] ✓ Feedback Loop ready');

      const { pedagogicalEngine } = await import('./pedagogical-engine.js');
      await pedagogicalEngine.init();
      _pedagogicalEngine = pedagogicalEngine;
      console.log('[IntelligenceHub] ✓ Pedagogical Engine ready');

      const { learningMemories } = await import('./learning-memories.js');
      await learningMemories.init();
      _learningMemories = learningMemories;
      console.log('[IntelligenceHub] ✓ Learning Memories ready');

      const { learningVelocity } = await import('./learning-velocity.js');
      await learningVelocity.init();
      _learningVelocity = learningVelocity;
      console.log('[IntelligenceHub] ✓ Learning Velocity ready');

      const { patternMiner } = await import('./pattern-miner.js');
      await patternMiner.init();
      _patternMiner = patternMiner;
      console.log('[IntelligenceHub] ✓ Pattern Miner ready');

      // Orchestration graph loaded last (depends on all others)
      const { graph } = await import('./orchestration-graph.js');
      _orchestrationGraph = graph;
      console.log('[IntelligenceHub] ✓ Orchestration Graph ready');

      // Trigger background pattern mining (non-blocking)
      if (_patternMiner) {
        _patternMiner.runMining().catch(e => {
          console.warn('[IntelligenceHub] Pattern mining error (non-critical):', e);
        });
      }

      this.initialized = true;
      this.initializing = false;
      
      console.log('[IntelligenceHub] All engines initialized ✓');
      this._emit('initialized', { timestamp: Date.now() });
      
    } catch (error) {
      this.initializing = false;
      console.error('[IntelligenceHub] Initialization error:', error);
      // Don't throw - hub should degrade gracefully
    }
  }

  /**
   * Called BEFORE a hint is generated by tutor.js
   * Returns enriched context with intervention style
   * 
   * @param {Object} context - The hint request context
   * @returns {Object} Enriched context with interventionStyle, ruleAdditions
   */
  async beforeHint(context) {
    if (!this.initialized) return { interventionStyle: null, ruleAdditions: '' };
    
    try {
      const { conceptId, userQuery, struggleData } = context;
      const userId = 'default';
      
      // 1. Detect misconception type
      let misconceptionType = null;
      let interventionRecommendations = [];
      
      if (_pedagogicalEngine && struggleData) {
        const analysis = await _pedagogicalEngine.analyzeMisconception(
          struggleData,
          conceptId,
          { userCode: context.userCode, testFailures: context.failingTests }
        );
        misconceptionType = analysis.misconceptionType;
        interventionRecommendations = analysis.recommendedInterventions;
      }
      
      // 2. Get memory-based preference for intervention style
      let interventionStyle = null;
      
      if (_learningMemories) {
        const preference = _learningMemories.getPreferredInterventionStyle({
          conceptId,
          misconceptionType
        });
        if (preference) {
          interventionStyle = preference.style;
        }
      }
      
      // 3. If no memory preference, use pedagogical engine recommendation
      if (!interventionStyle && _pedagogicalEngine && misconceptionType) {
        const selection = await _pedagogicalEngine.selectIntervention(
          misconceptionType,
          userId,
          { frustrationLevel: struggleData?.struggleLevel }
        );
        interventionStyle = selection.recommendedStyle;
      }
      
      // 4. Get applicable rules from memories
      let ruleAdditions = '';
      if (_learningMemories) {
        const rules = _learningMemories.getApplicableRules({
          conceptId,
          misconceptionType,
          struggleLevel: struggleData?.struggleLevel
        });
        if (rules.length > 0) {
          const topRules = rules.slice(0, 2).map(r => r.rule.value?.suggestedApproach || '').filter(Boolean);
          if (topRules.length > 0) {
            ruleAdditions = `Preferred approach: ${topRules.join(', ')}.`;
          }
        }
      }
      
      // 5. Get velocity prediction
      let timeEstimate = null;
      if (_learningVelocity && conceptId) {
        try {
          const estimate = await _learningVelocity.estimateTimeToMastery(conceptId, userId);
          timeEstimate = estimate.estimatedMinutes;
        } catch (_) {
          // Non-critical
        }
      }
      
      // Track current session state
      this.currentSession.conceptId = conceptId;
      this.currentSession.misconceptionType = misconceptionType;
      this.currentSession.interventionStyle = interventionStyle;
      this.currentSession.hintStartTime = Date.now();
      
      return {
        interventionStyle,
        misconceptionType,
        ruleAdditions,
        timeEstimate,
        interventionRecommendations
      };
      
    } catch (error) {
      console.warn('[IntelligenceHub] beforeHint error (non-critical):', error);
      return { interventionStyle: null, ruleAdditions: '' };
    }
  }

  /**
   * Called AFTER a hint is delivered by tutor.js
   * Records the hint delivery for tracking
   * 
   * @param {string} hintId - Hint identifier
   * @param {Object} hint - The generated hint
   * @param {Object} context - Original context
   */
  async afterHint(hintId, hint, context) {
    if (!this.initialized) return;
    
    try {
      this.currentSession.hintId = hintId;
      
      // Observe this hint delivery in learning memories
      if (_learningMemories) {
        await _learningMemories.observe({
          type: 'hint_request',
          conceptId: this.currentSession.conceptId,
          misconceptionType: this.currentSession.misconceptionType,
          interventionStyle: this.currentSession.interventionStyle,
          metadata: { hintId, mode: context?.mode }
        });
      }
      
      this._emit('hint_delivered', { hintId, conceptId: this.currentSession.conceptId });
      
    } catch (error) {
      console.warn('[IntelligenceHub] afterHint error (non-critical):', error);
    }
  }

  /**
   * Called when a test passes (from outcome-tracker.js)
   * Runs the full feedback loop
   * 
   * @param {string} hintId - Hint that led to the pass
   * @param {number} timeToPass - Minutes to pass
   * @param {string} conceptId - Concept that was mastered
   */
  async onOutcome(hintId, outcome, timeToPass, conceptId) {
    if (!this.initialized) return;
    
    try {
      const userId = 'default';
      const outcomeStr = outcome; // 'passed' | 'failed' | 'abandoned'
      const timeInSeconds = timeToPass ? timeToPass * 60 : null;
      
      // 1. Run full feedback loop (internally updates BKT mastery + misconception graph)
      if (_feedbackLoop) {
        await _feedbackLoop.processOutcome({
          hintId,
          conceptId: conceptId || this.currentSession.conceptId,
          misconceptionType: this.currentSession.misconceptionType,
          interventionStyle: this.currentSession.interventionStyle,
          outcome: outcomeStr,
          timeToOutcome: timeInSeconds,
          struggleData: { struggleLevel: this.currentSession.struggleLevel },
          attemptsCount: null,
          userId
        });
      }
      
      // 2. Track velocity progress (feedbackLoop does NOT handle this)
      if (_learningVelocity && (conceptId || this.currentSession.conceptId)) {
        const elapsedMinutes = this.currentSession.hintStartTime
          ? (Date.now() - this.currentSession.hintStartTime) / 60000
          : timeToPass || 5;
        
        await _learningVelocity.trackVelocityProgress(
          conceptId || this.currentSession.conceptId,
          elapsedMinutes,
          outcomeStr === 'passed',
          userId
        );
      }
      
      // 4. Observe in memories
      if (_learningMemories) {
        await _learningMemories.observe({
          type: 'outcome',
          conceptId: conceptId || this.currentSession.conceptId,
          misconceptionType: this.currentSession.misconceptionType,
          interventionStyle: this.currentSession.interventionStyle,
          outcome: outcomeStr,
          timeToOutcome: timeInSeconds,
          struggleLevel: this.currentSession.struggleLevel
        });
      }
      
      // Check for pending approvals and emit
      if (_learningMemories) {
        const pending = _learningMemories.getPendingApprovals();
        if (pending.length > 0) {
          this._emit('pending_approvals', { count: pending.length, approvals: pending });
        }
      }
      
      // Reset session state
      if (outcomeStr === 'passed') {
        this.currentSession.hintId = null;
        this.currentSession.misconceptionType = null;
        this.currentSession.interventionStyle = null;
      }
      
      this._emit('outcome_processed', { hintId, outcome: outcomeStr, conceptId });
      
    } catch (error) {
      console.warn('[IntelligenceHub] onOutcome error (non-critical):', error);
    }
  }

  /**
   * Called when struggle level changes (from struggle-detector.js / panel-v2.js)
   * 
   * @param {string} level - 'none' | 'gentle' | 'active' | 'supportive'
   * @param {Object} context - Current context
   */
  async onStruggle(level, context = {}) {
    if (!this.initialized) return;
    
    try {
      this.currentSession.struggleLevel = level;
      
      // Observe struggle in memories
      if (_learningMemories && level !== 'none') {
        await _learningMemories.observe({
          type: 'struggle',
          conceptId: context.conceptId || this.currentSession.conceptId,
          struggleLevel: level,
          metadata: { context }
        });
      }
      
      // Get velocity blockers
      if (_learningVelocity && level === 'supportive' && this.currentSession.conceptId) {
        const blockers = await _learningVelocity.identifyVelocityBlockers(
          this.currentSession.conceptId
        );
        if (blockers.length > 0) {
          this._emit('velocity_blockers', { blockers, conceptId: this.currentSession.conceptId });
        }
      }
      
    } catch (error) {
      console.warn('[IntelligenceHub] onStruggle error (non-critical):', error);
    }
  }

  /**
   * Called when a concept is passed (from concept-graph.js)
   * Updates BKT mastery directly
   * 
   * @param {string} conceptId - Concept identifier
   * @param {number} timeToPass - Time in seconds (optional)
   */
  async onConceptPassed(conceptId, timeToPass = null) {
    if (!this.initialized || !conceptId) return;
    
    try {
      // Update BKT mastery
      if (_bktEngine) {
        await _bktEngine.updateMastery(conceptId, true);
      }
      
      // Track velocity
      if (_learningVelocity) {
        const minutes = timeToPass ? timeToPass / 60 : 5;
        await _learningVelocity.trackVelocityProgress(conceptId, minutes, true);
      }
      
    } catch (error) {
      console.warn('[IntelligenceHub] onConceptPassed error (non-critical):', error);
    }
  }

  /**
   * Called when a concept is viewed (from concept-graph.js)
   */
  async onConceptViewed(conceptId) {
    if (!this.initialized || !conceptId) return;
    
    try {
      this.currentSession.conceptId = conceptId;
      
      // Register KC if not already registered
      if (_bktEngine) {
        await _bktEngine.getOrCreateKC(conceptId);
      }
    } catch (error) {
      console.warn('[IntelligenceHub] onConceptViewed error (non-critical):', error);
    }
  }

  /**
   * Approve a pending memory suggestion
   * @param {string} approvalId - Approval identifier
   */
  async approveMemory(approvalId) {
    if (!_learningMemories) return null;
    
    const result = await _learningMemories.approve(approvalId);
    this._emit('memory_approved', { approvalId, memory: result.memory });
    return result;
  }

  /**
   * Reject a pending memory suggestion
   * @param {string} approvalId - Approval identifier
   */
  async rejectMemory(approvalId) {
    if (!_learningMemories) return null;
    
    const result = await _learningMemories.reject(approvalId);
    this._emit('memory_rejected', { approvalId });
    return result;
  }

  /**
   * Get pending memory approvals for UI display
   */
  getPendingApprovals() {
    if (!_learningMemories) return [];
    return _learningMemories.getPendingApprovals();
  }

  /**
   * Get current mastery for a concept
   */
  getMastery(conceptId) {
    if (!_bktEngine) return null;
    return _bktEngine.getMastery(conceptId);
  }

  /**
   * Get mastery summary for the user
   */
  getMasterySummary() {
    if (!_bktEngine) return null;
    return _bktEngine.getMasterySummary();
  }

  /**
   * Get velocity statistics
   */
  getVelocityStats() {
    if (!_learningVelocity) return null;
    return _learningVelocity.getStatistics();
  }

  /**
   * Get concepts due for review
   */
  async getConceptsDueForReview() {
    if (!_learningVelocity) return [];
    return _learningVelocity.getConceptsDueForReview();
  }

  /**
   * Get feedback statistics
   */
  getFeedbackStats() {
    if (!_feedbackLoop) return null;
    return _feedbackLoop.getStatistics();
  }

  /**
   * Get memory statistics
   */
  getMemoryStats() {
    if (!_learningMemories) return null;
    return _learningMemories.getStatistics();
  }

  /**
   * Get pattern miner statistics
   */
  getMinerStats() {
    if (!_patternMiner) return null;
    return _patternMiner.getStatistics();
  }

  /**
   * Get weak knowledge components for recommendations
   */
  getWeakConcepts() {
    if (!_bktEngine) return [];
    return _bktEngine.getWeakKCs();
  }

  /**
   * Get a complete system status snapshot
   */
  async getSystemStatus() {
    const status = {
      initialized: this.initialized,
      engines: {
        orchestrationGraph: !!_orchestrationGraph,
        bktEngine: !!_bktEngine,
        pedagogicalEngine: !!_pedagogicalEngine,
        feedbackLoop: !!_feedbackLoop,
        learningMemories: !!_learningMemories,
        learningVelocity: !!_learningVelocity,
        patternMiner: !!_patternMiner
      }
    };
    
    if (this.initialized) {
      status.mastery = this.getMasterySummary();
      status.velocity = this.getVelocityStats();
      status.feedback = this.getFeedbackStats();
      status.memories = this.getMemoryStats();
      status.patterns = this.getMinerStats();
      status.pendingApprovals = this.getPendingApprovals().length;
      status.reviewsDue = (await this.getConceptsDueForReview()).length;
    }
    
    return status;
  }

  // Event system for UI integration
  on(event, listener) {
    if (!this._listeners.has(event)) {
      this._listeners.set(event, []);
    }
    this._listeners.get(event).push(listener);
  }

  off(event, listener) {
    if (!this._listeners.has(event)) return;
    const listeners = this._listeners.get(event);
    const idx = listeners.indexOf(listener);
    if (idx >= 0) listeners.splice(idx, 1);
  }

  _emit(event, data) {
    if (!this._listeners.has(event)) return;
    for (const listener of this._listeners.get(event)) {
      try {
        listener(data);
      } catch (e) {
        console.warn('[IntelligenceHub] Listener error:', e);
      }
    }
  }
}

// Export singleton
export const hub = new IntelligenceHub();

export default hub;
